This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
options/
  index.html
  options.js
background.js
content.js
manifest.json
page_inject.js
plan.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="options/index.html">
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CaptionCards Settings</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#fff; color:#000; }
    .wrap { max-width: 820px; margin: 24px auto; padding: 16px; border:3px solid #000; box-shadow: 8px 8px #000; }
    h1 { margin: 0 0 16px 0; }
    .row { display:flex; gap:12px; align-items:center; margin:8px 0; }
    label { width: 160px; font-weight: 700; }
    input, select { border:2px solid #000; padding:6px 8px; width: 100%; }
    .btn { background:#000; color:#fff; border:2px solid #000; padding:8px 12px; cursor:pointer; }
    .hint { color:#333; font-size:12px; }
  </style>
  <script defer src="options.js"></script>
  </head>
<body>
  <div class="wrap">
    <h1>CaptionCards Settings</h1>
    <div class="row">
      <label>Provider</label>
      <select id="provider">
        <option value="gemini">Google Gemini</option>
        <option value="openai">OpenAI</option>
        <option value="anthropic">Anthropic Claude</option>
        <option value="openrouter">OpenRouter</option>
      </select>
    </div>
    <div class="row">
      <label>Base URL (optional)</label>
      <input id="baseUrl" placeholder="auto by provider" />
    </div>
    <div class="row">
      <label>Model</label>
      <input id="model" placeholder="e.g. gemini-2.5-flash" />
    </div>
    <div class="row">
      <label>API Key</label>
      <input id="apiKey" placeholder="paste your key" />
    </div>
    <div class="row">
      <label>Accent</label>
      <select id="accent">
        <option value="us">American</option>
        <option value="uk">British</option>
      </select>
    </div>
    <div class="row">
      <button class="btn" id="save">Save</button>
      <button class="btn" id="test">Test</button>
      <div class="hint" id="status"></div>
    </div>
  </div>
</body>
</html>
</file>

<file path="options/options.js">
const DEFAULTS = {
  provider: 'gemini',
  baseUrl: '',
  apiKey: '',
  model: 'gemini-2.5-flash',
  accent: 'us'
};

async function load() {
  const { settings } = await chrome.storage.local.get('settings');
  const s = { ...DEFAULTS, ...(settings || {}) };
  document.getElementById('provider').value = s.provider;
  document.getElementById('baseUrl').value = s.baseUrl || '';
  document.getElementById('model').value = s.model || '';
  document.getElementById('apiKey').value = s.apiKey || '';
  document.getElementById('accent').value = s.accent || 'us';
}

async function save() {
  const s = {
    provider: document.getElementById('provider').value,
    baseUrl: document.getElementById('baseUrl').value.trim(),
    model: document.getElementById('model').value.trim(),
    apiKey: document.getElementById('apiKey').value.trim(),
    accent: document.getElementById('accent').value
  };
  await chrome.storage.local.set({ settings: s });
  const el = document.getElementById('status');
  el.textContent = 'Saved';
  setTimeout(() => el.textContent = '', 1500);
}

document.addEventListener('DOMContentLoaded', () => {
  load();
  document.getElementById('save').addEventListener('click', save);
  document.getElementById('test').addEventListener('click', test);
});

async function test() {
  const override = {
    provider: document.getElementById('provider').value,
    baseUrl: document.getElementById('baseUrl').value.trim(),
    model: document.getElementById('model').value.trim(),
    apiKey: document.getElementById('apiKey').value.trim(),
  };
  const status = document.getElementById('status');
  status.textContent = 'Testing…';
  try {
    const res = await chrome.runtime.sendMessage({ type: 'CC_TEST_LLM', override });
    if (res && res.ok) {
      status.textContent = 'Test OK';
    } else {
      status.textContent = 'Test failed: ' + (res && res.error || 'Unknown');
    }
  } catch (e) {
    status.textContent = 'Test error: ' + (e && e.message || e);
  }
  setTimeout(() => status.textContent = '', 3000);
}
</file>

<file path="background.js">
// Background service worker (MV3, ESM)

// Default settings
const DEFAULT_SETTINGS = {
  provider: 'gemini',
  baseUrl: '', // will derive by provider
  apiKey: '',
  model: 'gemini-2.5-flash',
  accent: 'us' // 'us' or 'uk'
};

async function getSettings() {
  const { settings } = await chrome.storage.local.get('settings');
  return { ...DEFAULT_SETTINGS, ...(settings || {}) };
}

async function setSettings(next) {
  await chrome.storage.local.set({ settings: next });
}

// Ensure defaults exist once installed
chrome.runtime.onInstalled.addListener(async (details) => {
  const s = await getSettings();
  await setSettings(s);
  // Only open options page on first install, not on every update/reload
  if (details.reason === 'install' && !s.apiKey) {
    try { await chrome.runtime.openOptionsPage(); } catch (e) {}
  }
});

// Open modal in the active tab when the action is clicked
chrome.action.onClicked.addListener(async (tab) => {
  if (!tab.id) return;
  try {
    await chrome.tabs.sendMessage(tab.id, { type: 'CC_TOGGLE_MODAL' });
  } catch (e) {
    // Content script may not be injected for this tab state; try to inject then send
    try {
      await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        files: ['content.js']
      });
      await chrome.tabs.sendMessage(tab.id, { type: 'CC_TOGGLE_MODAL' });
    } catch (err) {
      console.error('Failed to open modal:', err);
    }
  }
});

// Generic LLM call routing
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if (msg && msg.type === 'CC_LLM_CALL') {
    (async () => {
      try {
        const result = await handleLLMCall(msg.payload);
        sendResponse({ ok: true, result });
      } catch (err) {
        sendResponse({ ok: false, error: String(err && err.message || err) });
      }
    })();
    return true; // keep channel open for async
  }
  if (msg && msg.type === 'CC_OPEN_OPTIONS') {
    chrome.runtime.openOptionsPage(() => {
      if (chrome.runtime.lastError) {
        console.warn('openOptionsPage failed:', chrome.runtime.lastError.message);
      }
      sendResponse({ ok: true });
    });
    return true;
  }
  if (msg && msg.type === 'CC_GET_SETTINGS') {
    (async () => {
      const s = await getSettings();
      sendResponse({ ok: true, settings: s });
    })();
    return true;
  }
  if (msg && msg.type === 'CC_TEST_LLM') {
    (async () => {
      try {
        const override = msg.override || {};
        const settings = { ...(await getSettings()), ...override };
        const { provider, baseUrl, apiKey, model } = settings;
        if (!apiKey) throw new Error('API key missing');
        const text = await callProvider({ provider, baseUrl, apiKey, model, prompt: 'Return this exact JSON: {"ok":true}' });
        let ok = false;
        try {
          const jsonStr = extractJson(text);
          const parsed = JSON.parse(jsonStr);
          ok = parsed && parsed.ok === true;
        } catch {}
        if (!ok) throw new Error('Unexpected response: ' + (text || '(empty)'));
        sendResponse({ ok: true });
      } catch (e) {
        sendResponse({ ok: false, error: String(e && e.message || e) });
      }
    })();
    return true;
  }
});

async function handleLLMCall(payload) {
  const settings = await getSettings();
  const { role, data } = payload; // role: 'first'|'second'

  const { provider, baseUrl, apiKey, model, accent } = settings;
  if (!apiKey) throw new Error('Missing API key in settings');

  const prompts = buildPrompts(role, data, accent);

  const text = await callProvider({ provider, baseUrl, apiKey, model, prompt: prompts.prompt });
  // Expect JSON in text; try to parse
  let parsed;
  try {
    const jsonStr = extractJson(text);
    parsed = JSON.parse(jsonStr);
  } catch (e) {
    throw new Error('LLM returned non-JSON or invalid JSON. Raw: ' + truncate(text, 800));
  }
  return parsed;
}

function buildPrompts(role, data, accent) {
  if (role === 'first') {
    const { subtitlesText, maxItems = 60 } = data;
    const system = `You are an expert English vocabulary curator for learners with intermediate+ proficiency. Remove trivial or banal items.`;
    const user = `Task: From the transcript below, extract high-value words and short expressions that are worth deliberate study. Exclude trivial/basic examples such as: apple, orange, banana, I don't know, you know, good morning, how are you, thanks, hello.

Return JSON strictly with this shape:
{
  "items": [ { "term": string, "type": "word"|"phrase", "freq": number } ]
}
Rules:
- Rank by usefulness/frequency in this specific transcript, not general corpora.
- Avoid overly-rare named entities unless broadly useful.
- Prefer multi-word expressions if they are idiomatic or hard to translate.
- freq is a rough integer frequency count or weight.
- Limit items to about ${maxItems}.

Transcript (English, lightly noisy, do minimal normalization to understand):\n\n${subtitlesText}`;
    return { prompt: composeChat(system, user) };
  } else if (role === 'second') {
    const { selected } = data;
    const accentLabel = accent === 'uk' ? 'British' : 'American';
    const system = `You are a concise English lexicographer. Output clean IPA and succinct meanings.`;
    const user = `Task: For each item, produce phonetic transcription (IPA, ${accentLabel}), part of speech, a short learner-friendly definition, 1-2 example sentences (prefer common, you may adapt from everyday usage), and a brief note for meme/culture/common confusions if relevant. Keep it compact.

Return JSON strictly with this shape:
{
  "cards": [ {
    "term": string,
    "ipa": string,            // IPA (${accentLabel})
    "pos": string,            // e.g., noun, verb, adj.
    "definition": string,     // concise learner definition
    "examples": string[],     // 1-2 examples
    "notes": string           // may be empty
  } ]
}

Items:\n${selected.map((t, i) => `${i + 1}. ${t.term}`).join('\n')}`;
    return { prompt: composeChat(system, user) };
  }
  throw new Error('Unknown role');
}

function composeChat(system, user) {
  // Provider adapters will wrap into their specific schema. Here we merge as a single text.
  return `SYSTEM:\n${system}\n\nUSER:\n${user}`;
}

async function callProvider({ provider, baseUrl, apiKey, model, prompt }) {
  const p = provider.toLowerCase();
  if (p === 'gemini' || p === 'google') {
    const url = (baseUrl && baseUrl.trim()) || `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [ { role: 'user', parts: [ { text: prompt } ] } ]
      })
    });
    if (!res.ok) throw new Error(`Gemini error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    const text = (data.candidates?.[0]?.content?.parts?.map(p => p.text).join('\n')) || '';
    return text;
  }
  if (p === 'openai') {
    const url = (baseUrl && baseUrl.trim()) || 'https://api.openai.com/v1/chat/completions';
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: 'system', content: 'You are a helpful assistant.' },
          { role: 'user', content: prompt }
        ]
      })
    });
    if (!res.ok) throw new Error(`OpenAI error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    return data.choices?.[0]?.message?.content || '';
  }
  if (p === 'claude' || p === 'anthropic') {
    const url = (baseUrl && baseUrl.trim()) || 'https://api.anthropic.com/v1/messages';
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model,
        max_tokens: 2048,
        messages: [ { role: 'user', content: prompt } ]
      })
    });
    if (!res.ok) throw new Error(`Anthropic error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    const content = data.content?.[0]?.text || '';
    return content;
  }
  if (p === 'openrouter') {
    const url = (baseUrl && baseUrl.trim()) || 'https://openrouter.ai/api/v1/chat/completions';
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [ { role: 'user', content: prompt } ]
      })
    });
    if (!res.ok) throw new Error(`OpenRouter error ${res.status}: ${await res.text()}`);
    const data = await res.json();
    return data.choices?.[0]?.message?.content || '';
  }
  throw new Error('Unsupported provider: ' + provider);
}

function extractJson(text) {
  // Try to find the first {...} or [{...}] JSON block
  const match = text.match(/[\{\[][\s\S]*[\}\]]/);
  return match ? match[0] : text;
}

function truncate(s, n) {
  return s.length > n ? s.slice(0, n) + '…' : s;
}
</file>

<file path="content.js">
// Content script: injects UI, extracts YouTube captions, orchestrates LLM flow

const CC_NS = 'CCAPTIONCARDS';

// Simple state
let modalOpen = false;
let uiRoot = null;
let currentState = {
  videoId: null,
  title: null,
  subtitlesText: null,
  candidates: null,
  selected: null,
  cards: null,
  error: null,
};

chrome.runtime.onMessage.addListener((msg) => {
  if (msg && msg.type === 'CC_TOGGLE_MODAL') {
    toggleModal();
  }
});

function toggleModal() {
  if (modalOpen) {
    closeModal();
  } else {
    openModal();
  }
}

function openModal() {
  modalOpen = true;
  if (!uiRoot) createUI();
  uiRoot.style.display = 'block';
  bootFlow();
}

function closeModal() {
  modalOpen = false;
  if (uiRoot) uiRoot.style.display = 'none';
}

function createUI() {
  uiRoot = document.createElement('div');
  uiRoot.id = 'cc-root';
  const style = document.createElement('style');
  style.textContent = getStyles();
  document.documentElement.appendChild(style);

  uiRoot.innerHTML = `
    <div class="cc-overlay" role="dialog" aria-modal="true">
      <div class="cc-modal">
        <div class="cc-header">
          <div class="cc-title">CaptionCards</div>
          <div class="cc-actions">
            <button class="cc-icon" id="cc-settings" title="Settings" aria-label="Settings">${iconSettings()}</button>
            <button class="cc-icon" id="cc-close" title="Close" aria-label="Close">${iconClose()}</button>
          </div>
        </div>
        <div class="cc-body">
          <div id="cc-step"></div>
          <div id="cc-content"></div>
        </div>
        <div class="cc-footer">
          <button class="cc-btn" id="cc-regenerate" title="Regenerate">Regenerate</button>
          <button class="cc-btn danger" id="cc-delete" title="Delete All">Delete All</button>
          <button class="cc-btn" id="cc-export" title="Export CSV">Export</button>
        </div>
      </div>
    </div>
  `;
  document.documentElement.appendChild(uiRoot);

  uiRoot.querySelector('#cc-close').addEventListener('click', closeModal);
  uiRoot.querySelector('#cc-settings').addEventListener('click', () => chrome.runtime.sendMessage({ type: 'CC_OPEN_OPTIONS' }));
  uiRoot.querySelector('#cc-regenerate').addEventListener('click', () => startFlow(true));
  uiRoot.querySelector('#cc-delete').addEventListener('click', deleteAllForThisVideo);
  uiRoot.querySelector('#cc-export').addEventListener('click', exportCSV);
}

function getStyles() {
  return `
    #cc-root { position: fixed; inset: 0; z-index: 2147483647; display:none; }
    .cc-overlay { position: absolute; inset:0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; }
    .cc-modal { width: min(960px, 96vw); height: min(680px, 92vh); background:#fff; color:#000; border:3px solid #000; box-shadow: 8px 8px #000; display:flex; flex-direction:column; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .cc-header { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:3px solid #000; background: #f5f5f5; }
    .cc-title { font-weight: 800; letter-spacing: 1px; }
    .cc-actions { display:flex; gap:8px; }
    .cc-icon { background:#000; color:#fff; border:2px solid #000; width:32px; height:32px; display:grid; place-items:center; cursor:pointer; }
    .cc-icon:hover { transform: translate(-1px, -1px); box-shadow: 2px 2px #000; }
    .cc-body { flex:1; overflow:auto; padding:12px; background: repeating-linear-gradient(45deg, #fafafa, #fafafa 2px, #f0f0f0 2px, #f0f0f0 4px); }
    .cc-footer { display:flex; gap:8px; padding:10px 12px; border-top:3px solid #000; background:#f5f5f5; }
    .cc-btn { background:#000; color:#fff; border:2px solid #000; padding:8px 12px; cursor:pointer; }
    .cc-btn.danger { background:#fff; color:#000; border-color:#000; }
    .cc-step { font-size:14px; margin-bottom:8px; }
    .cc-progress { display:flex; gap:8px; margin-bottom:12px; }
    .cc-stepchip { padding:6px 8px; border:2px solid #000; background:#fff; }
    .cc-stepchip.active { background:#000; color:#fff; }
    .cc-list { display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
    .cc-card { border:2px solid #000; padding:12px; background:#fff; margin-bottom:8px; }
    .cc-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:8px; }
    .cc-flex { display:flex; gap:8px; align-items:center; }
    .cc-controls { display:flex; gap:8px; margin:8px 0; align-items:center; }
    .cc-input { padding:6px 8px; border:2px solid #000; }
    .cc-small { color:#333; font-size:12px; }
    .cc-spinner { width: 18px; height: 18px; border: 3px solid #000; border-right-color: transparent; border-radius: 50%; animation: ccspin 0.8s linear infinite; }
    @keyframes ccspin { to { transform: rotate(360deg); } }
  `;
}

function iconClose() {
  return `<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true"><path d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 7.11 5.7A1 1 0 0 0 5.7 7.11L10.59 12l-4.9 4.89a1 1 0 1 0 1.41 1.41L12 13.41l4.89 4.9a1 1 0 0 0 1.41-1.41L13.41 12l4.9-4.89a1 1 0 0 0-.01-1.4z"/></svg>`;
}
function iconSettings() {
  return `<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true"><path d="M19.14,12.94a7.43,7.43,0,0,0,.05-.94,7.43,7.43,0,0,0-.05-.94l2.11-1.65a.48.48,0,0,0,.12-.61l-2-3.46a.5.5,0,0,0-.6-.22l-2.49,1a7,7,0,0,0-1.63-.94l-.38-2.65A.5.5,0,0,0,13.72,2H10.28a.5.5,0,0,0-.5.42L9.4,5.07a7,7,0,0,0-1.63.94l-2.49-1a.5.5,0,0,0-.6.22l-2,3.46a.5.5,0,0,0,.12.61L5,11.06a7.43,7.43,0,0,0-.05.94,7.43,7.43,0,0,0,.05.94L2.86,14.59a.48.48,0,0,0-.12.61l2,3.46a.5.5,0,0,0,.6.22l2.49-1a7,7,0,0,0,1.63.94l.38,2.65a.5.5,0,0,0,.5.42h3.44a.5.5,0,0,0,.5-.42l.38-2.65a7,7,0,0,0,1.63-.94l2.49,1a.5.5,0,0,0,.6-.22l2-3.46a.5.5,0,0,0-.12-.61ZM12,15.5A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z"/></svg>`;
}

async function bootFlow() {
  // Load settings to determine onboarding
  const settings = await getSettings();
  if (!settings.apiKey) {
    setStep(['Setup LLM', 'Extract captions', 'Build cards'], 1);
    renderOnboarding();
    return;
  }
  // Load any saved data first
  const { videoId, title } = getYouTubeVideoInfo();
  currentState.videoId = videoId;
  currentState.title = title;
  const saved = await loadVideoData(videoId);
  if (saved && saved.cards && saved.cards.length) {
    currentState.subtitlesText = saved.subtitlesText || null;
    currentState.candidates = saved.candidates || null;
    currentState.selected = saved.selected || null;
    currentState.cards = saved.cards || null;
    renderLearnView();
    setStep(['Extract captions', 'Filter words', 'Build cards'], 3);
    return;
  }
  // Otherwise start fresh
  startFlow();
}

async function startFlow(forceRegenerate = false) {
  currentState.error = null;
  setStep(['Extract captions', 'Filter words', 'Build cards'], 1);
  renderProgress('Extracting captions…');
  try {
    const { videoId, title } = getYouTubeVideoInfo();
    currentState.videoId = videoId;
    currentState.title = title;
    if (!forceRegenerate) {
      const saved = await loadVideoData(videoId);
      if (saved && saved.cards?.length) {
        currentState = { ...currentState, ...saved };
        renderLearnView();
        setStep(['Extract captions', 'Filter words', 'Build cards'], 3);
        return;
      }
    }
    const subtitlesText = await extractCaptionsText();
    currentState.subtitlesText = subtitlesText;
    await saveVideoData(currentState.videoId, { subtitlesText, title });
  } catch (e) {
    currentState.error = String(e?.message || e);
    renderError('Captions error', currentState.error);
    return;
  }

  // LLM #1
  setStep(['Extract captions', 'Filter words', 'Build cards'], 2);
  renderProgress('Filtering words/phrases…');
  try {
    const resp = await llmCall('first', { subtitlesText: currentState.subtitlesText, maxItems: 60 });
    currentState.candidates = resp.items || [];
    await saveVideoData(currentState.videoId, { candidates: currentState.candidates });
  } catch (e) {
    currentState.error = String(e?.message || e);
    renderError('LLM #1 error', currentState.error);
    return;
  }

  // Selection UI
  renderSelection();
}

function setStep(steps, activeIndex) {
  const stepEl = uiRoot.querySelector('#cc-step');
  stepEl.innerHTML = `<div class="cc-progress">${steps.map((s, i) => `<div class="cc-stepchip ${i+1===activeIndex?'active':''}">${s}</div>`).join('')}</div>`;
}

function renderProgress(text) {
  const content = uiRoot.querySelector('#cc-content');
  content.innerHTML = `<div class="cc-card"><div class="cc-flex"><div class="cc-spinner"></div><div>${text}</div></div></div>`;
}

function renderError(title, err) {
  const content = uiRoot.querySelector('#cc-content');
  content.innerHTML = `<div class="cc-card"><div><b>${title}</b></div><pre>${escapeHtml(err)}</pre></div>`;
}

function renderSelection() {
  const content = uiRoot.querySelector('#cc-content');
  const items = currentState.candidates || [];
  const header = `
    <div class="cc-controls">
      <button class="cc-btn" id="cc-sel-all">Select All</button>
      <button class="cc-btn" id="cc-next">Next</button>
    </div>
  `;
  const list = `
    <div class="cc-list" id="cc-cand-list">
      ${items.map((it, idx) => `
        <div class="cc-flex"><input type="checkbox" data-idx="${idx}" ${it.selected? 'checked':''}/> <div><b>${escapeHtml(it.term)}</b> <span class="cc-small">(${escapeHtml(it.type||'word')}, freq ${it.freq ?? '-'})</span></div></div>
        <div class="cc-small"></div>
      `).join('')}
    </div>
  `;
  content.innerHTML = `<div class="cc-card"><div><b>Review and select items</b></div>${header}${list}</div>`;
  content.querySelector('#cc-sel-all').addEventListener('click', () => {
    content.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
  });
  content.querySelector('#cc-next').addEventListener('click', async () => {
    const selected = [];
    content.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      if (cb.checked) {
        const idx = Number(cb.getAttribute('data-idx'));
        const it = items[idx];
        selected.push({ term: it.term, type: it.type || 'word' });
      }
    });
    currentState.selected = selected;
    await saveVideoData(currentState.videoId, { selected });
    buildCards();
  });
}

async function buildCards() {
  setStep(['Extract captions', 'Filter words', 'Build cards'], 3);
  renderProgress('Generating study cards…');
  try {
    const resp = await llmCall('second', { selected: currentState.selected });
    currentState.cards = resp.cards || [];
    await saveVideoData(currentState.videoId, { cards: currentState.cards });
    renderLearnView();
  } catch (e) {
    currentState.error = String(e?.message || e);
    renderError('LLM #2 error', currentState.error);
  }
}

function renderLearnView() {
  const content = uiRoot.querySelector('#cc-content');
  const cards = currentState.cards || [];
  if (!cards.length) {
    content.innerHTML = '<div class="cc-card">No cards yet.</div>';
    return;
  }
  let idx = 0;
  const renderBig = () => `
    <div class="cc-card">
      <div class="cc-controls">
        <button class="cc-btn" id="cc-prev">Prev</button>
        <div class="cc-small">${idx+1} / ${cards.length}</div>
        <button class="cc-btn" id="cc-nextcard">Next</button>
        <button class="cc-btn" id="cc-togglegrid">Grid</button>
        <button class="cc-btn" id="cc-save">Save</button>
      </div>
      ${renderCardEditor(cards[idx])}
    </div>
  `;
  const renderGrid = () => `
    <div class="cc-grid">
      ${cards.map(c => `<div class="cc-card"><div><b>${escapeHtml(c.term)}</b></div><div class="cc-small">/${escapeHtml(c.ipa||'')}/ · ${escapeHtml(c.pos||'')}</div><div>${escapeHtml(c.definition||'')}</div></div>`).join('')}
    </div>
  `;
  let grid = false;
  const doRender = () => {
    content.innerHTML = grid ? renderGrid() : renderBig();
    if (!grid) {
      content.querySelector('#cc-prev').addEventListener('click', () => { idx = (idx - 1 + cards.length) % cards.length; doRender(); });
      content.querySelector('#cc-nextcard').addEventListener('click', () => { idx = (idx + 1) % cards.length; doRender(); });
      content.querySelector('#cc-togglegrid').addEventListener('click', () => { grid = true; doRender(); });
      content.querySelector('#cc-save').addEventListener('click', async () => {
        const edited = readCardEditor();
        cards[idx] = edited;
        await saveVideoData(currentState.videoId, { cards });
      });
    } else {
      // In grid mode, clicking card toggles back to big view at that index
      Array.from(content.querySelectorAll('.cc-card')).forEach((el, i) => {
        el.style.cursor = 'pointer';
        el.addEventListener('click', () => { idx = i; grid = false; doRender(); });
      });
    }
  };
  doRender();
}

function renderCardEditor(card) {
  const c = { term: '', ipa: '', pos: '', definition: '', examples: [], notes: '', ...card };
  return `
    <div class="cc-flex"><label style="width:80px">Term</label><input class="cc-input" id="cc-term" value="${escapeAttr(c.term)}"/></div>
    <div class="cc-flex"><label style="width:80px">IPA</label><input class="cc-input" id="cc-ipa" value="${escapeAttr(c.ipa)}"/></div>
    <div class="cc-flex"><label style="width:80px">POS</label><input class="cc-input" id="cc-pos" value="${escapeAttr(c.pos)}"/></div>
    <div class="cc-flex"><label style="width:80px">Definition</label><input class="cc-input" id="cc-def" value="${escapeAttr(c.definition)}"/></div>
    <div class="cc-flex"><label style="width:80px">Examples</label><textarea class="cc-input" id="cc-ex" rows="3">${escapeHtml((c.examples||[]).join('\n'))}</textarea></div>
    <div class="cc-flex"><label style="width:80px">Notes</label><textarea class="cc-input" id="cc-notes" rows="2">${escapeHtml(c.notes||'')}</textarea></div>
  `;
}

function readCardEditor() {
  const term = document.getElementById('cc-term').value.trim();
  const ipa = document.getElementById('cc-ipa').value.trim();
  const pos = document.getElementById('cc-pos').value.trim();
  const definition = document.getElementById('cc-def').value.trim();
  const examples = document.getElementById('cc-ex').value.split('\n').map(s => s.trim()).filter(Boolean);
  const notes = document.getElementById('cc-notes').value.trim();
  return { term, ipa, pos, definition, examples, notes };
}

function escapeHtml(s) {
  return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
}
function escapeAttr(s) {
  return String(s).replace(/["&<>]/g, c => ({'"':'&quot;','&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
}

async function deleteAllForThisVideo() {
  if (!currentState.videoId) return;
  await saveVideoData(currentState.videoId, { subtitlesText: null, candidates: null, selected: null, cards: null, title: currentState.title });
  currentState = { ...currentState, subtitlesText: null, candidates: null, selected: null, cards: null };
  startFlow(true);
}

async function exportCSV() {
  const cards = currentState.cards || [];
  if (!cards.length) return;
  const rows = [['term', 'ipa', 'pos', 'definition', 'notes']]
    .concat(cards.map(c => [c.term||'', c.ipa||'', c.pos||'', c.definition||'', c.notes||'']))
    .map(r => r.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(','))
    .join('\r\n');
  const csv = '\ufeff' + rows; // BOM for Excel
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const safeTitle = (currentState.title || 'export').replace(/[\\/:*?"<>|]/g, '_');
  a.download = safeTitle + '.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function loadVideoData(videoId) {
  const key = `${CC_NS}:video:${videoId}`;
  const data = await chrome.storage.local.get(key);
  return data[key] || null;
}

async function saveVideoData(videoId, patch) {
  const key = `${CC_NS}:video:${videoId}`;
  const current = await loadVideoData(videoId) || {};
  const next = { ...current, ...patch };
  await chrome.storage.local.set({ [key]: next });
}

function getYouTubeVideoInfo() {
  const url = new URL(location.href);
  let v = url.searchParams.get('v');
  if (!v) {
    // youtu.be/ID form or shorts
    const paths = location.pathname.split('/').filter(Boolean);
    if (paths[0] === 'shorts' && paths[1]) v = paths[1];
    if (!v && location.host.includes('youtu.be')) v = paths[0];
  }
  const titleEl = document.querySelector('h1.title, h1#title, h1');
  const title = titleEl ? titleEl.textContent.trim() : document.title.replace(' - YouTube', '').trim();
  return { videoId: v, title };
}

async function extractCaptionsText() {
  console.log('[CC] Starting caption extraction...');
  
  // Try robust main-world player response first
  try {
    console.log('[CC] Attempting to get player response from main world...');
    const injected = await getPlayerResponseMainWorld();
    console.log('[CC] Player response received:', !!injected, injected ? Object.keys(injected) : 'null');
    
    let tracks = injected?.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
    console.log('[CC] Caption tracks found:', tracks.length, tracks.map(t => ({ lang: t.languageCode, kind: t.kind })));
    
    const isEnglish = (t) => (t.languageCode || '').toLowerCase().startsWith('en');
    const nonAsr = tracks.filter(t => isEnglish(t) && !t.kind);
    const asr = tracks.filter(t => isEnglish(t) && t.kind === 'asr');
    const pick = nonAsr[0] || asr[0];
    
    console.log('[CC] Filtered tracks - nonAsr:', nonAsr.length, 'asr:', asr.length, 'picked:', !!pick);
    
    if (pick && pick.baseUrl) {
      console.log('[CC] Using baseUrl:', pick.baseUrl);
      // Prefer srv3(JSON) first, fallback to vtt
      const base = pick.baseUrl;
      // Prefer json3 (current) and keep srv3 as a backup
      const json3Url = base + (base.includes('fmt=') ? '' : (base.includes('?') ? '&' : '?') + 'fmt=json3');
      const srv3Url = base + (base.includes('fmt=') ? '' : (base.includes('?') ? '&' : '?') + 'fmt=srv3');
      // Try JSON first (via main-world fetch proxy)
      try {
        console.log('[CC] Trying JSON format (json3):', json3Url);
        let res = await fetchCaptionMainWorld(json3Url);
        const ct = res.contentType || '';
        console.log('[CC] JSON response status:', res.status, 'content-type:', ct);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        if (ct.includes('application/json') || ct.includes('+json')) {
          const data = JSON.parse(res.text || 'null');
          const text = captionsJsonToText(data);
          console.log('[CC] JSON parsed, text length:', text.length);
          if (text.trim()) return text;
        } else {
          // Some servers still return JSON with text/plain
          const raw = res.text || '';
          console.log('[CC] Got raw text, length:', raw.length, 'first 100 chars:', raw.substring(0, 100));
          try {
            const data = JSON.parse(raw);
            const text = captionsJsonToText(data);
            console.log('[CC] Raw text parsed as JSON, text length:', text.length);
            if (text.trim()) return text;
          } catch {
            // Not JSON, fallthrough to VTT
            console.log('[CC] Raw text is not JSON, trying as VTT...');
            const text = captionsVttToText(raw);
            if (text.trim()) return text;
          }
        }
      } catch (e) {
        console.log('[CC] JSON (json3) format failed:', e.message);
        // Try legacy srv3 before VTT
        try {
          console.log('[CC] Trying legacy JSON format (srv3):', srv3Url);
          const res2 = await fetchCaptionMainWorld(srv3Url);
          const ct2 = res2.contentType || '';
          console.log('[CC] srv3 response status:', res2.status, 'content-type:', ct2);
          if (res2.ok) {
            if (ct2.includes('application/json') || ct2.includes('+json')) {
              const data2 = JSON.parse(res2.text || 'null');
              const text2 = captionsJsonToText(data2);
              console.log('[CC] srv3 JSON parsed, text length:', text2.length);
              if (text2.trim()) return text2;
            } else {
              const raw2 = res2.text || '';
              try {
                const data2 = JSON.parse(raw2);
                const text2 = captionsJsonToText(data2);
                if (text2.trim()) return text2;
              } catch {}
            }
          }
        } catch (e2) {
          console.log('[CC] srv3 also failed:', e2.message);
        }
        // continue to VTT
      }
      // VTT fallback
      try {
        const vttUrl = base + (base.includes('fmt=') ? '' : (base.includes('?') ? '&' : '?') + 'fmt=vtt');
        console.log('[CC] Trying VTT format:', vttUrl);
        const vttRes = await fetchCaptionMainWorld(vttUrl);
        console.log('[CC] VTT response status:', vttRes.status);
        if (vttRes.ok) {
          const vttText = vttRes.text || '';
          console.log('[CC] VTT text length:', vttText.length);
          const text = captionsVttToText(vttText);
          console.log('[CC] VTT parsed text length:', text.length);
          if (text.trim()) return text;
        }
      } catch (e) {
        console.log('[CC] VTT format failed:', e.message);
      }
    }

    // No direct English track; try translating available tracks to English via tlang=en
    if (!pick && tracks.length) {
      console.log('[CC] No English track; attempting translation via tlang=en');
      for (const t of tracks) {
        if (!t.baseUrl) continue;
        const base = t.baseUrl + (t.baseUrl.includes('?') ? '&' : '?') + 'tlang=en';
        const json3Url = base + (base.includes('fmt=') ? '' : '&fmt=json3');
        const vttUrl = base + (base.includes('fmt=') ? '' : '&fmt=vtt');
        try {
          console.log('[CC] Trying translated JSON (json3):', json3Url);
          const res = await fetchCaptionMainWorld(json3Url);
          if (res.ok) {
            const ct = res.contentType || '';
            if (ct.includes('application/json') || ct.includes('+json')) {
              const data = JSON.parse(res.text || 'null');
              const text = captionsJsonToText(data);
              if (text.trim()) return text;
            } else {
              const raw = res.text || '';
              try { const data = JSON.parse(raw); const text = captionsJsonToText(data); if (text.trim()) return text; } catch {}
            }
          }
        } catch (e) {
          console.log('[CC] Translated JSON failed:', e.message);
        }
        try {
          console.log('[CC] Trying translated VTT:', vttUrl);
          const res2 = await fetchCaptionMainWorld(vttUrl);
          if (res2.ok) {
            const vttText = res2.text || '';
            const text = captionsVttToText(vttText);
            if (text.trim()) return text;
          }
        } catch (e2) {
          console.log('[CC] Translated VTT failed:', e2.message);
        }
      }
    }
  } catch (e) {
    console.log('[CC] Player response method failed:', e.message);
    // continue to fallback
  }
  
  // Fallback timedtext endpoints
  console.log('[CC] Trying fallback timedtext endpoints...');
  const { videoId } = getYouTubeVideoInfo();
  console.log('[CC] Video ID:', videoId);
  
  if (!videoId) {
    throw new Error('Could not determine video ID from current page');
  }
  
  const tries = [
    `https://www.youtube.com/api/timedtext?lang=en&v=${encodeURIComponent(videoId)}&fmt=json3`,
    `https://www.youtube.com/api/timedtext?lang=en&kind=asr&v=${encodeURIComponent(videoId)}&fmt=json3`,
    `https://www.youtube.com/api/timedtext?lang=en-US&v=${encodeURIComponent(videoId)}&fmt=json3`,
    `https://www.youtube.com/api/timedtext?lang=en-GB&v=${encodeURIComponent(videoId)}&fmt=json3`,
    // allow automatic translation to English when only non-English tracks exist
    `https://www.youtube.com/api/timedtext?tlang=en&v=${encodeURIComponent(videoId)}&fmt=json3`,
    `https://www.youtube.com/api/timedtext?tlang=en&v=${encodeURIComponent(videoId)}&fmt=vtt`,
    `https://www.youtube.com/api/timedtext?lang=en&v=${encodeURIComponent(videoId)}&fmt=vtt`,
    `https://www.youtube.com/api/timedtext?lang=en&kind=asr&v=${encodeURIComponent(videoId)}&fmt=vtt`,
  ];
  
  for (const url of tries) {
    try {
      console.log('[CC] Trying fallback URL:', url);
      const res = await fetchCaptionMainWorld(url);
      console.log('[CC] Fallback response status:', res.status);
      if (!res.ok) continue;
      const ct = res.contentType || '';
      console.log('[CC] Fallback content-type:', ct);
      if (ct.includes('application/json') || ct.includes('+json')) {
        const data = JSON.parse(res.text || 'null');
        const text = captionsJsonToText(data);
        console.log('[CC] Fallback JSON text length:', text.length);
        if (text && text.trim()) return text;
      } else {
        // Try text -> JSON parse, else treat as VTT
        const raw = res.text || '';
        console.log('[CC] Fallback raw text length:', raw.length);
        try {
          const data = JSON.parse(raw);
          const text = captionsJsonToText(data);
          console.log('[CC] Fallback raw->JSON text length:', text.length);
          if (text && text.trim()) return text;
        } catch {
          const text = captionsVttToText(raw);
          console.log('[CC] Fallback raw->VTT text length:', text.length);
          if (text && text.trim()) return text;
        }
      }
    } catch (e) {
      console.log('[CC] Fallback URL failed:', url, e.message);
    }
  }
  
  console.log('[CC] All caption extraction methods failed');
  throw new Error('No available English captions for this video.');
}

// Fetch caption via page main-world proxy installed by page_inject.js
function fetchCaptionMainWorld(url) {
  return new Promise((resolve) => {
    const id = 'f_' + Math.random().toString(36).slice(2);
    const onMsg = (event) => {
      if (event.source !== window) return;
      const d = event.data;
      if (!d || d.type !== 'CC_FETCH_CAPTION_RESULT' || d.id !== id) return;
      window.removeEventListener('message', onMsg);
      resolve({ ok: !!d.ok, status: d.status || 0, contentType: d.contentType || '', text: d.text || '', error: d.error });
    };
    window.addEventListener('message', onMsg);
    // Ensure injector is present (getPlayerResponseMainWorld injects it when called earlier)
    try { window.postMessage({ type: 'CC_FETCH_CAPTION', id, url }, '*'); } catch (e) {
      window.removeEventListener('message', onMsg);
      resolve({ ok: false, status: 0, contentType: '', text: '', error: String(e) });
    }
    // Timeout safeguard
    setTimeout(() => {
      try { window.removeEventListener('message', onMsg); } catch {}
      resolve({ ok: false, status: 0, contentType: '', text: '', error: 'timeout' });
    }, 10000);
  });
}

function captionsJsonToText(json) {
  // json3/srv3 has events[].segs[].utf8
  if (!json || !Array.isArray(json.events)) return '';
  const parts = [];
  for (const ev of json.events) {
    if (!ev.segs) continue;
    const line = ev.segs.map(s => s.utf8).join('').replace(/\s+/g, ' ').trim();
    if (line) parts.push(line);
  }
  return parts.join('\n');
}

function captionsVttToText(vtt) {
  if (!vtt) return '';
  // Remove WEBVTT header and notes
  const lines = String(vtt)
    .replace(/^\uFEFF/, '')
    .split(/\r?\n/);
  const out = [];
  let buf = [];
  const flush = () => {
    const s = buf.join(' ').replace(/\s+/g, ' ').trim();
    if (s) out.push(s);
    buf = [];
  };
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) { flush(); continue; }
    if (i === 0 && /^WEBVTT/i.test(line)) continue;
    if (/^NOTE(\s|$)/i.test(line)) continue;
    if (/^\d+$/.test(line)) continue; // cue number
    if (/^\d{2}:\d{2}:\d{2}\.\d{3}\s+--\>/.test(line) || /^\d{2}:\d{2}\.\d{3}\s+--\>/.test(line)) {
      // time line, ignore
      continue;
    }
    // Strip HTML tags that sometimes appear in VTT
    const text = line.replace(/<[^>]+>/g, '').trim();
    if (text) buf.push(text);
  }
  flush();
  return out.join('\n');
}

function getPlayerResponseMainWorld() {
  return new Promise((resolve) => {
    const onMsg = (event) => {
      if (event.source !== window) return;
      const d = event.data;
      if (!d || d.type !== 'CC_PLAYER_RESPONSE') return;
      window.removeEventListener('message', onMsg);
      resolve(d.payload || null);
    };
    window.addEventListener('message', onMsg);
    const s = document.createElement('script');
    s.src = chrome.runtime.getURL('page_inject.js');
    (document.head || document.documentElement).appendChild(s);
    s.addEventListener('load', () => setTimeout(() => s.remove(), 0));
  });
}

async function llmCall(role, data) {
  const resp = await chrome.runtime.sendMessage({ type: 'CC_LLM_CALL', payload: { role, data } });
  if (!resp || !resp.ok) throw new Error(resp && resp.error || 'Unknown error');
  return resp.result;
}

async function getSettings() {
  const resp = await chrome.runtime.sendMessage({ type: 'CC_GET_SETTINGS' });
  if (!resp || !resp.ok) return {};
  return resp.settings || {};
}

function renderOnboarding() {
  const content = uiRoot.querySelector('#cc-content');
  content.innerHTML = `
    <div class="cc-card">
      <div><b>First-time setup required</b></div>
      <p class="cc-small">Please configure your LLM provider, model, API key, and accent before generating cards.</p>
      <div class="cc-controls">
        <button class="cc-btn" id="cc-open-settings">Open Settings</button>
        <button class="cc-btn" id="cc-continue">I have configured</button>
      </div>
    </div>
  `;
  content.querySelector('#cc-open-settings').addEventListener('click', () => chrome.runtime.sendMessage({ type: 'CC_OPEN_OPTIONS' }));
  content.querySelector('#cc-continue').addEventListener('click', async () => {
    const s = await getSettings();
    if (!s.apiKey) {
      alert('API key is still missing. Please save settings.');
      return;
    }
    startFlow(true);
  });
}
</file>

<file path="manifest.json">
{
  "manifest_version": 3,
  "name": "CaptionCards",
  "version": "0.1.0",
  "description": "Extract YouTube captions, filter key words/phrases with LLM, and generate study cards.",
  "action": {
    "default_title": "CaptionCards"
  },
  "permissions": [
    "storage",
    "scripting",
    "activeTab"
  ],
  "host_permissions": [
    "https://www.youtube.com/*",
    "https://*.youtube.com/*",
    "https://*.googlevideo.com/*",
    "https://api.openai.com/*",
    "https://api.anthropic.com/*",
    "https://openrouter.ai/*",
    "https://openrouter.ai/api/*",
    "https://generativelanguage.googleapis.com/*"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "options_page": "options/index.html",
  "content_scripts": [
    {
      "matches": ["https://www.youtube.com/*"],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ],
  "web_accessible_resources": [
    {
      "resources": ["page_inject.js", "assets/*"],
      "matches": ["https://www.youtube.com/*"]
    }
  ]
}
</file>

<file path="page_inject.js">
(() => {
  function post(pr, error) {
    try {
      window.postMessage({ type: 'CC_PLAYER_RESPONSE', payload: pr || null, error: error ? String(error) : undefined }, '*');
    } catch (e) {
      try { window.postMessage({ type: 'CC_PLAYER_RESPONSE', payload: null, error: String(e) }, '*'); } catch {}
    }
  }
  function readPR() {
    try {
      // Try multiple sources for player response
      let pr = window.ytInitialPlayerResponse;
      if (!pr && window.ytplayer && window.ytplayer.config && window.ytplayer.config.args) {
        const args = window.ytplayer.config.args;
        if (args.player_response) {
          try {
            pr = JSON.parse(args.player_response);
          } catch {}
        }
      }
      // Also try from ytPlayerConfig if available
      if (!pr && window.ytPlayerConfig && window.ytPlayerConfig.args && window.ytPlayerConfig.args.player_response) {
        try {
          pr = JSON.parse(window.ytPlayerConfig.args.player_response);
        } catch {}
      }
      return pr;
    } catch (e) {
      return null;
    }
  }
  
  // Try immediate read first
  const immediate = readPR();
  if (immediate) {
    post(immediate);
  } else {
    // If not available, poll for it
    const start = Date.now();
    const timeoutMs = 8000; // wait up to 8s (increased)
    const int = setInterval(() => {
      const pr = readPR();
      if (pr) {
        clearInterval(int);
        post(pr);
      } else if (Date.now() - start > timeoutMs) {
        clearInterval(int);
        post(null, 'Timed out waiting for ytInitialPlayerResponse');
      }
    }, 150); // check more frequently
  }

  // Caption fetch proxy: allow content script to fetch via page context
  window.addEventListener('message', async (event) => {
    const d = event && event.data;
    if (!d || d.type !== 'CC_FETCH_CAPTION' || !d.url || !d.id) return;
    try {
      const res = await fetch(d.url, { credentials: 'include' });
      const ct = res.headers.get('content-type') || '';
      const text = await res.text();
      window.postMessage({ type: 'CC_FETCH_CAPTION_RESULT', id: d.id, ok: !!res.ok, status: res.status, contentType: ct, text }, '*');
    } catch (e) {
      try { window.postMessage({ type: 'CC_FETCH_CAPTION_RESULT', id: d.id, ok: false, status: 0, contentType: '', text: '', error: String(e) }, '*'); } catch {}
    }
  });
})();
</file>

<file path="plan.md">
## 目标
我想做一款 chrome 和 edge 的浏览器插件，能够自动提取 youtube 视频的字幕，然后发送给 llm 一号，进行单词和短语的筛选去噪，去掉太简单太日常的单词和短语。然后对高频词汇和表达进行标注。接着把结果发送给 llm 二号，打上音标，释义，例句，以及相应说明（包括但不限于一些 meme，或者文化，或者常见混淆之类的说明）。所以说，基本上还是一个 agent 系统，有一个多轮合作的架构以减少幻觉，提高结果质量。另外，我还想做一个系统，也就是在一号和二号 llm 的中间穿插一个手动筛选的环节：通过提示词约束，将1号 llm 的输出实现一个列表可视化，做一个列表让用户可以自由选择一号 llm 所提取出来的单词纳入学习计划，并将结果以合理的格式传递给二号 llm。最后，将筛选出来的每一个单词和表达，以及二号 llm 所添加的音标，释义，例句和相应说明渲染成一个个美观的 html 单词卡片，即大卡片视图，让用户可以前后切换，反复学习。并且设置小卡片视图，直观可视化所有单词和表达（单词+词性+音标+释义，表达+释义），注意不要过于拥挤，一定要美观，做到跟屏幕大小实现自适应。然后还需要添加一个导出按钮，允许用户将所有单词和表达导出为 excel 表格（每一列为单词/表达，音标，词性，释义，相关说明）


## 注意
- 太简单如 apple , banana, I don't know 这类的单词和表达不要纳入。
- 做一个单独标签页的设置界面，允许用户自定义 llm 的 provider， base url，apikey，model id 以添加来自特定 provider 的模型（如 openai/gpt-5）。并且允许设置一号 llm 和二号 llm 的模型。（最好还是让用户选择供应商，目前支持 openai，claude，gemini 和 openrouter 即可，不做太多参数给用户自定义），总之设置界面最好符合直觉，直观美观，并且方便使用。
- 关于 UI，用户只需要点击插件按钮，就可以打开一个比较大的模态框，首先显示“正在提取字幕”，提取成功就给个动画，接着“正在提取单词和表达，并去噪”，成功动画，然后“正在生成学习卡片”，成功动画。如果不成功，那大概率是来自提供商的 llm报错，只需要原封不动地显示报错即可。总之就是想要一个流畅且美观的线性流程，给人一种 agent 运行的感觉。当全部完成之后，就以大卡片视图一个一个展示学习卡片，用户可以随时关闭，也可以选择重头再来，也可以点击“完成”关闭学习界面（点击插件图标可以重新打开，但不要重新获取！除非用户刷新了页面），还可以导出，也可以切换小卡片视图进行快速浏览，也可以自己编辑卡片具体内容，也可以进入设置界面。
- 整体设计要简洁美观，避免臃肿，用第一性原理思考，在满足用户使用的同时遵循奥卡姆剃刀原则去设计。所有按钮尽量用 直观的 svg 图标，不要用文字。动画要优雅灵动。整体设计使用复古优雅且简洁的黑白细颗粒度的像素风设计。

## 技术栈
typescript
</file>

</files>
